./functional_programming/Test/Other_7.lean
namespace Other_7

-- (x+1) × 2 + (x+1) × 3
def f(x: Nat) : Nat :=
  let y := x + 1; -- use semicolon to separate
  y * 2 + y * 3

#eval f 1 -- 10

-- list of pairs to pair of lists
def myUnzip : List (α × β) → List α × List β
  | [] => ([], [])
  | (x, y) :: xys =>
    let (xs, ys) : List α × List β := myUnzip xys ; -- recursive call
    (x :: xs, y :: ys)

-- let rec : for recursive function
def myReverse (xs : List α) : List α :=
  let rec helper : List α → List α → List α
    | [], soFar => soFar
    | y :: ys, soFar => helper ys (y :: soFar)
  helper xs []

-- if let - another way to pattern matching
inductive Animal
  | cat : String → Animal
  | dog : String → Animal
  | fish : String → Animal
  deriving Repr

def catName : Animal → Option String := λ a =>
  if let Animal.cat name := a then
    Option.some name
  else
    Option.none

#eval catName (Animal.cat "Mittens") -- some "Mittens"
#eval catName (Animal.dog "Fido") -- none




end Other_7
./functional_programming/Test/Recursion_5.lean

namespace Recursion_5

/-
Datatypes that allow choices are called sum types
and datatypes that can include instances of themselves are called recursive datatypes.
Recursive sum types are called inductive datatypes,
because mathematical induction may be used to prove statements about them.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.
-/

-- builtin Nat
-- Natural is a recursive datatype
-- zero is a constructor
-- succ is a constructor that takes a Natural and returns a Natural
-- succ is a recursive constructor
inductive Natural where
  | zero: Natural
  | succ: Natural → Natural
  deriving Repr

def zero := Natural.zero
def one := Natural.succ zero
def two := Natural.succ one
def three := Natural.succ two
def four := Natural.succ three
def five := Natural.succ four

#eval two

-- pattern matching
def isZero (n: Natural): Bool :=
  match n with
  | Natural.zero => true
  | Natural.succ _ => false -- _ wildcard pattern

#eval isZero zero -- true
#eval isZero one -- false

-- another example - pred : predecessor
def pred (n: Natural): Natural :=
  match n with
  | Natural.zero => Natural.zero
  | Natural.succ m => m

#eval pred two

structure Point2 where make_point::
  x: Int
  y: Int
  deriving Repr

-- pattern matching on structure
def getX (p: Point2): Int :=
  match p with
  | {x := xx, y := _} => xx

def onAxes (p: Point2): Bool :=
  match p with
  | {x := 0, y := _} => True
  | {x := _, y := 0} => True
  | _ => False

#eval getX {x := 1, y := 2} -- 1
#eval onAxes {x := 0, y := 2} -- true
#eval onAxes {x := 1, y := 0} -- true
#eval onAxes {x := 1, y := 2} -- false
#eval onAxes {x := 0, y := 0} -- true

-- recursive function
def isEven (n: Natural): Bool :=
  match n with
  | Natural.zero => true
  | Natural.succ m => not (isEven m)

#eval isEven zero -- true
#eval isEven one -- false
#eval isEven two -- true
#eval isEven three -- false

-- another example
def add (a: Natural) (b: Natural): Natural :=
  match a with
  | Natural.zero => b
  | Natural.succ m => add m (Natural.succ b)

def equal (a: Natural) (b: Natural): Bool :=
  match a, b with
  | Natural.zero, Natural.zero => true
  | Natural.succ m, Natural.succ n => equal m n
  | _, _ => false

#eval equal five (add two three)


-- this example does not work since `div` requires a manual proof of termination
/-
g parameter k of Recursion_5.div:
  it is unchanged in the recursive calls
Cannot use parameter k:
  failed to eliminate recursive application
    div (n - k) k


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
k n : Nat
h✝ : ¬n < k
⊢ n - k < n
error: Lean exited with code 1
Some required builds logged failures:
- Test.Recursion_5
error: build failed

def div (n : Nat) (k : Nat) : Nat :=
  if n < k then
    0
  else Nat.succ (div (n - k) k)

-/

end Recursion_5
./functional_programming/Test/Type_2.lean
namespace Type_2


#eval 1 - 2

#eval (1 - 2: Nat) -- set type after operation -- will be zero

#eval (1 - 2: Int) -- set type after operation

#check (1 - 2: Int) -- check type -- will be calculate

#eval ((1: Nat) + (2: Nat)) -- set type before operation

end Type_2
./functional_programming/Test/Basic_1.lean
-- basic examples

namespace Basic_1 -- namespace

def add1 (n : Nat) : Nat := n + 1

#eval add1 7 -- #eval will appear as info and calculated at compile time

#eval 1 + 2

#eval (String.append "great " (String.append "oak " "tree"))

#eval (String.append "it is " (if 1 > 2 then "yes" else "no"))

end Basic_1 -- end namespace
./functional_programming/Test/Polymorphism_6.lean
namespace Polymorphism_6


-- type as parameter
structure Point (α: Type) where
  x: α
  y: α
  deriving Repr


def p1 : Point Int := { x := 1, y := 2 }
def p2 : Point Float := { x := 1.0, y := 2.0 }

#eval p1 -- Point Int
#eval p2 -- Point Float

def updateX {α: Type} (p: Point α) (xx: α): Point α :=
  { p with x := xx }

#check updateX

#eval updateX p1 3 -- update x to 3
#eval updateX p2 3.0 -- update x to 3.0

-- implicit {α : Type}
def updateXX (p: Point α) (xx: α): Point α :=
  { p with x := xx }

-- implicit (α: Type)
def updateY: Point α → α → Point α
  | p,yy => { p with y := yy } -- update y to y




inductive Sign where
  | pos
  | neg

-- return (3 : Nat) if is positive, (-3 : Int) if negative
-- return type is determined by the value of s
def posOrNegThree (s : Sign) : (match s with
  | Sign.pos => Nat
  | Sign.neg => Int
) := (match s with
    | Sign.pos => (3 : Nat)
    | Sign.neg => (-3 : Int)
)

#check posOrNegThree

-- builtin List
inductive MyList (α: Type) where
  | nil : MyList α
  | cons : α → MyList α → MyList α

-- three ways to define bultin List
def ll1 := [1, 2, 3]
def ll2 := List.cons 1 (List.cons 2 (List.cons 3 List.nil))
def ll3 := [1::[2, 3]] -- :: is like cons

#eval [ll1, ll2]




def MyList.append (l: MyList α) (e: α) :=
  MyList.cons e l

def l1 := MyList.nil.append  1
def l2 := l1.append  2
def l3 := l2.append  3

#eval l3

def MyList.len (l : MyList α): Nat :=
  match l with
  | MyList.nil => 0
  | MyList.cons _ l => 1 + l.len

#eval l3.len


-- builtin Option
inductive MyOption (α : Type) : Type where
  | none : MyOption α
  | some: (val : α) → MyOption α
  deriving Repr


def x := MyOption.some 1
def y : MyOption Nat := MyOption.none

#eval [x, y]


def MyList.head (l: MyList α) : MyOption α :=
  match l with
  | MyList.nil => MyOption.none
  | MyList.cons e _ => MyOption.some e

#eval l3.head

#eval (MyList.nil : MyList Int).head

-- builtin Prod - Product
structure MyProd (α : Type) (β : Type) : Type where
  fst : α
  snd : β
  deriving Repr

-- three ways to define builtin Product
def fives1 : Prod String Int := {fst:= "five", snd := 5}

def fives2 : String × Int := { fst := "five", snd := 5 }

def fives3 : String × Int := ("five", 5)

-- builtin Sum - Coproduct
inductive MySum (α : Type) (β : Type) : Type where
  | inl : α → MySum α β
  | inr : β → MySum α β
  deriving Repr

-- two ways to define builtin Sum
def z1: Sum Nat Float := Sum.inl 1
def z2: Nat ⊕ Float := Sum.inr 2.0

-- builtin Unit, Empty


end Polymorphism_6
./functional_programming/Test/Structure_4.lean
namespace Structure_4

-- some float example

#check (1.2: Float)

#check -454.2123215

#check 0.0

#check 0 -- Nat not Float


-- cartesian coordinates
structure Point3 where
  x: Float
  y: Float
  z: Int := 0 -- default value
  deriving Repr -- deriving Repr to print the structure

#eval ({x := 1.0, y := 2.0}: Point3) -- create a Point3

def p : Point3 := { x := 2.0, y := -1.0 }

#eval p

#eval p.x -- get field x

-- add two Point3s
def addPoint3s (p1: Point3) (p2: Point3) : Point3 :=
  { x := p1.x + p2.x, y := p1.y + p2.y }

-- distance between two Point3s
def distance (p1 : Point3) (p2 : Point3) : Float :=
  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))

#eval distance p {x := 5.0, y := -1.0}

#eval {x := 1.0, y := 2.0: Point3} -- syntactic sugar to create a Point3


-- set field x to zero
def setXzero (p: Point3) : Point3 :=
  { x := 0.0, y := p.y, z := p.z }

-- a better way to set field x to one
def setXoneZtwo (p: Point3) : Point3 :=
  { p with x := 1.0, z := 2 }

#eval setXzero p -- set field x to zero
#eval setXoneZtwo p -- set field x to one and z to two


-- default constructor
#check Point3.mk 1.0 2.0 3 -- create a Point3

-- overwrite default constructor name
structure Point2 where make_point::
  x: Float
  y: Float
  deriving Repr

#check Point2.make_point 1.0 2.0 -- create a Point2

#check Point2.x -- Point2.x is a function

-- method for p1
def Point2.sub (p1: Point2) (p2: Point2) : Point2 :=
  { x := p1.x - p2.x, y := p1.y - p2.y }

#eval Point2.sub {x := 3.0, y := 4.0} {x := 1.0, y := 2.0}

#eval ({x := 3.0, y := 4.0}: Point2).sub {x := 1.0, y := 2.0} -- syntactic sugar to call a method

end Structure_4
./functional_programming/Test/Function_3.lean

namespace Function_3

-- function (or variable - anything is a function) without arguments
def hello: String := "world"

#eval hello

def lean: String := "Lean" -- with type

#eval lean

-- two ways to define a function
-- 1. using def
-- 2. using fun - lambda expression

def add2 (n: Nat): Nat := n + 2

def add3: Nat → Nat := fun n => n + 3

def add4: Nat → Nat := λ n => n + 4
def add5: Nat → Nat := ( · + 5 )
def add6: Nat → Nat := λ n ↦ n + 6

#eval [(add2 3), (add3 3), (add4 3), (add5 3)] -- will be list [5, 6, 7, 8]

-- two ways to define a function with two arguments
-- 1. using def
-- 2. using fun - lambda expression (curried function)

def mysum1 (a: Nat) (b: Nat): Nat := a + b
def mysum2: Nat → Nat → Nat := fun a b => a + b
def mysum3: Nat → Nat → Nat := fun a => fun b => a + b
def mysum4: Nat → Nat → Nat
  | a, b => a + b -- using pattern matching

#eval [(mysum1 3 4), (mysum2 3 4), (mysum3 3 4), (mysum4 3 4)] -- will be list [7, 7, 7, 7]

#check [mysum1, mysum2, mysum3, mysum4] -- check type

#check [mysum1 3, mysum2 3, mysum3 3, mysum4 3] -- check type




def Str1: Type := String -- type as first class citizen
def Str2: Type := String → String

def aStr: Str1 := "hello"
def aStr2: Str2 := fun (s : String) => (s ++ " world": String)
def aStr3: Str2 := λ (s : String) => (s ++ " world": String)

#eval aStr3 aStr -- will be "hello world"

abbrev N: Type := Nat -- type alias - recommended way

end Function_3
./functional_programming/Main.lean
import Test


def main : IO Unit :=
  IO.println s!"Hello, world!"
./functional_programming/Test.lean
-- This module serves as the root of the `Test` library.
-- Import modules here that should be built as part of the library.
import Test.Basic_1
import Test.Type_2
import Test.Function_3
import Test.Structure_4
import Test.Recursion_5
import Test.Polymorphism_6
import Test.Other_7
./theorem_proving/theorem_proving/dependent_type_theory.lean
namespace DependentTypeTheory

/-
BASIC DEPENDENT TYPE THEORY

Consider the set of all formal strings `S` and the sematic equivalence relation `∼` on `S`. For example, `λ (x: Nat) → x + 4` and `fun (y: Nat) => y + 4` are two different strings but have the same semantic. We will use the same word `object` for both syntactic string and its meaning without confusion

In lean, every object longs to a `universe level`, below are some examples

- `universe level -1`: proofs
- `universe level 0`: `1`, `-2`, `1.4`, `"hello word"`, `λ (x: Nat) → x + 4`
- `universe level 1`: `Nat`, `Int`, `Float`, `String`, `Nat → Nat`
- `universe level 2`: `Type` (aka `Type 0` or `Sort 1`)
- `universe level 3`: `Type 1` (aka `Sort 2`)
- ...

Moreover, every object has a type, that is a function `t` that maps object from `universe level n` to `universe level n+1`. In programming, this is called getting type of (`type` in Python, `typeof` in Javascript). For example, `t(1) = Nat`, `t(true) = Bool`, `t(λ (x: Nat) => x + 4) = Nat → Nat`. Let `α` be any object at `universe level n+1`, the collection of all objects in `universe level n` of type `α` is called the `universe α`. For example, `universe Nat` consists of of all natural numbers. We write `x : Nat` to denote `x` is of type `Nat` and `x` is called a `term` (or `element` of `Nat`)

In lean, `t` is not exposed to user. However, during compilation process, lean allows user to print value and type of an object using `#eval` and `#check`
-/

#eval 20
#check 20

/-
ARROW TYPE

If `α` and `β` are two objects at `universe level n` and `universe level m` respectively, then `α → β` is an object at `universe level max(n, m)`. We will call it `arrow type`. when `f` is of arrow type `α → β`, we write `f : α → β` (or `f (a: α) : β` like function in programming)

Moreover, lean allows user to define dependent type, for example `g (α: Type) (b: β): γ α b` where `γ α b` is another object. A more concrete example is `make_vector (α: Type) (n: Nat): Vector α n` which is a function creating a vector of dimension `n` of type `α`
-/

inductive Vector (α : Type u) : Nat → Type u
| nil  : Vector α 0
| cons {n: Nat} : α → Vector α n → Vector α (n + 1)


def make_vector (α: Type) (n: Nat) [Inhabited α]: Vector α n :=
  match n with
  | 0 => Vector.nil
  | m+1 => Vector.cons default (make_vector α m)

end DependentTypeTheory
./theorem_proving/Main.lean
import theorem_proving.dependent_type_theory

def main : IO Unit :=
  IO.println s!"Hello, World!"
do you have any comment on this?

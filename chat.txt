./functional_programming/Test/Other_7.lean
namespace Other_7

-- (x+1) × 2 + (x+1) × 3
def f(x: Nat) : Nat :=
  let y := x + 1; -- use semicolon to separate
  y * 2 + y * 3

#eval f 1 -- 10

-- list of pairs to pair of lists
def myUnzip : List (α × β) → List α × List β
  | [] => ([], [])
  | (x, y) :: xys =>
    let (xs, ys) : List α × List β := myUnzip xys ; -- recursive call
    (x :: xs, y :: ys)

-- let rec : for recursive function
def myReverse (xs : List α) : List α :=
  let rec helper : List α → List α → List α
    | [], soFar => soFar
    | y :: ys, soFar => helper ys (y :: soFar)
  helper xs []

-- if let - another way to pattern matching
inductive Animal
  | cat : String → Animal
  | dog : String → Animal
  | fish : String → Animal
  deriving Repr

def catName : Animal → Option String := λ a =>
  if let Animal.cat name := a then
    Option.some name
  else
    Option.none

#eval catName (Animal.cat "Mittens") -- some "Mittens"
#eval catName (Animal.dog "Fido") -- none




end Other_7
./functional_programming/Test/Recursion_5.lean

namespace Recursion_5

/-
Datatypes that allow choices are called sum types
and datatypes that can include instances of themselves are called recursive datatypes.
Recursive sum types are called inductive datatypes,
because mathematical induction may be used to prove statements about them.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.
-/

-- builtin Nat
-- Natural is a recursive datatype
-- zero is a constructor
-- succ is a constructor that takes a Natural and returns a Natural
-- succ is a recursive constructor
inductive Natural where
  | zero: Natural
  | succ: Natural → Natural
  deriving Repr

def zero := Natural.zero
def one := Natural.succ zero
def two := Natural.succ one
def three := Natural.succ two
def four := Natural.succ three
def five := Natural.succ four

#eval two

-- pattern matching
def isZero (n: Natural): Bool :=
  match n with
  | Natural.zero => true
  | Natural.succ _ => false -- _ wildcard pattern

#eval isZero zero -- true
#eval isZero one -- false

-- another example - pred : predecessor
def pred (n: Natural): Natural :=
  match n with
  | Natural.zero => Natural.zero
  | Natural.succ m => m

#eval pred two

structure Point2 where make_point::
  x: Int
  y: Int
  deriving Repr

-- pattern matching on structure
def getX (p: Point2): Int :=
  match p with
  | {x := xx, y := _} => xx

def onAxes (p: Point2): Bool :=
  match p with
  | {x := 0, y := _} => True
  | {x := _, y := 0} => True
  | _ => False

#eval getX {x := 1, y := 2} -- 1
#eval onAxes {x := 0, y := 2} -- true
#eval onAxes {x := 1, y := 0} -- true
#eval onAxes {x := 1, y := 2} -- false
#eval onAxes {x := 0, y := 0} -- true

-- recursive function
def isEven (n: Natural): Bool :=
  match n with
  | Natural.zero => true
  | Natural.succ m => not (isEven m)

#eval isEven zero -- true
#eval isEven one -- false
#eval isEven two -- true
#eval isEven three -- false

-- another example
def add (a: Natural) (b: Natural): Natural :=
  match a with
  | Natural.zero => b
  | Natural.succ m => add m (Natural.succ b)

def equal (a: Natural) (b: Natural): Bool :=
  match a, b with
  | Natural.zero, Natural.zero => true
  | Natural.succ m, Natural.succ n => equal m n
  | _, _ => false

#eval equal five (add two three)


-- this example does not work since `div` requires a manual proof of termination
/-
g parameter k of Recursion_5.div:
  it is unchanged in the recursive calls
Cannot use parameter k:
  failed to eliminate recursive application
    div (n - k) k


failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
k n : Nat
h✝ : ¬n < k
⊢ n - k < n
error: Lean exited with code 1
Some required builds logged failures:
- Test.Recursion_5
error: build failed

def div (n : Nat) (k : Nat) : Nat :=
  if n < k then
    0
  else Nat.succ (div (n - k) k)

-/

end Recursion_5
./functional_programming/Test/Type_2.lean
namespace Type_2


#eval 1 - 2

#eval (1 - 2: Nat) -- set type after operation -- will be zero

#eval (1 - 2: Int) -- set type after operation

#check (1 - 2: Int) -- check type -- will be calculate

#eval ((1: Nat) + (2: Nat)) -- set type before operation

end Type_2
./functional_programming/Test/Basic_1.lean
-- basic examples

namespace Basic_1 -- namespace

def add1 (n : Nat) : Nat := n + 1

#eval add1 7 -- #eval will appear as info and calculated at compile time

#eval 1 + 2

#eval (String.append "great " (String.append "oak " "tree"))

#eval (String.append "it is " (if 1 > 2 then "yes" else "no"))

end Basic_1 -- end namespace
./functional_programming/Test/Polymorphism_6.lean
namespace Polymorphism_6


-- type as parameter
structure Point (α: Type) where
  x: α
  y: α
  deriving Repr


def p1 : Point Int := { x := 1, y := 2 }
def p2 : Point Float := { x := 1.0, y := 2.0 }

#eval p1 -- Point Int
#eval p2 -- Point Float

def updateX {α: Type} (p: Point α) (xx: α): Point α :=
  { p with x := xx }

#check updateX

#eval updateX p1 3 -- update x to 3
#eval updateX p2 3.0 -- update x to 3.0

-- implicit {α : Type}
def updateXX (p: Point α) (xx: α): Point α :=
  { p with x := xx }

-- implicit (α: Type)
def updateY: Point α → α → Point α
  | p,yy => { p with y := yy } -- update y to y




inductive Sign where
  | pos
  | neg

-- return (3 : Nat) if is positive, (-3 : Int) if negative
-- return type is determined by the value of s
def posOrNegThree (s : Sign) : (match s with
  | Sign.pos => Nat
  | Sign.neg => Int
) := (match s with
    | Sign.pos => (3 : Nat)
    | Sign.neg => (-3 : Int)
)

#check posOrNegThree

-- builtin List
inductive MyList (α: Type) where
  | nil : MyList α
  | cons : α → MyList α → MyList α

-- three ways to define bultin List
def ll1 := [1, 2, 3]
def ll2 := List.cons 1 (List.cons 2 (List.cons 3 List.nil))
def ll3 := [1::[2, 3]] -- :: is like cons

#eval [ll1, ll2]




def MyList.append (l: MyList α) (e: α) :=
  MyList.cons e l

def l1 := MyList.nil.append  1
def l2 := l1.append  2
def l3 := l2.append  3

#eval l3

def MyList.len (l : MyList α): Nat :=
  match l with
  | MyList.nil => 0
  | MyList.cons _ l => 1 + l.len

#eval l3.len


-- builtin Option
inductive MyOption (α : Type) : Type where
  | none : MyOption α
  | some: (val : α) → MyOption α
  deriving Repr


def x := MyOption.some 1
def y : MyOption Nat := MyOption.none

#eval [x, y]


def MyList.head (l: MyList α) : MyOption α :=
  match l with
  | MyList.nil => MyOption.none
  | MyList.cons e _ => MyOption.some e

#eval l3.head

#eval (MyList.nil : MyList Int).head

-- builtin Prod - Product
structure MyProd (α : Type) (β : Type) : Type where
  fst : α
  snd : β
  deriving Repr

-- three ways to define builtin Product
def fives1 : Prod String Int := {fst:= "five", snd := 5}

def fives2 : String × Int := { fst := "five", snd := 5 }

def fives3 : String × Int := ("five", 5)

-- builtin Sum - Coproduct
inductive MySum (α : Type) (β : Type) : Type where
  | inl : α → MySum α β
  | inr : β → MySum α β
  deriving Repr

-- two ways to define builtin Sum
def z1: Sum Nat Float := Sum.inl 1
def z2: Nat ⊕ Float := Sum.inr 2.0

-- builtin Unit, Empty


end Polymorphism_6
./functional_programming/Test/Structure_4.lean
namespace Structure_4

-- some float example

#check (1.2: Float)

#check -454.2123215

#check 0.0

#check 0 -- Nat not Float


-- cartesian coordinates
structure Point3 where
  x: Float
  y: Float
  z: Int := 0 -- default value
  deriving Repr -- deriving Repr to print the structure

#eval ({x := 1.0, y := 2.0}: Point3) -- create a Point3

def p : Point3 := { x := 2.0, y := -1.0 }

#eval p

#eval p.x -- get field x

-- add two Point3s
def addPoint3s (p1: Point3) (p2: Point3) : Point3 :=
  { x := p1.x + p2.x, y := p1.y + p2.y }

-- distance between two Point3s
def distance (p1 : Point3) (p2 : Point3) : Float :=
  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))

#eval distance p {x := 5.0, y := -1.0}

#eval {x := 1.0, y := 2.0: Point3} -- syntactic sugar to create a Point3


-- set field x to zero
def setXzero (p: Point3) : Point3 :=
  { x := 0.0, y := p.y, z := p.z }

-- a better way to set field x to one
def setXoneZtwo (p: Point3) : Point3 :=
  { p with x := 1.0, z := 2 }

#eval setXzero p -- set field x to zero
#eval setXoneZtwo p -- set field x to one and z to two


-- default constructor
#check Point3.mk 1.0 2.0 3 -- create a Point3

-- overwrite default constructor name
structure Point2 where make_point::
  x: Float
  y: Float
  deriving Repr

#check Point2.make_point 1.0 2.0 -- create a Point2

#check Point2.x -- Point2.x is a function

-- method for p1
def Point2.sub (p1: Point2) (p2: Point2) : Point2 :=
  { x := p1.x - p2.x, y := p1.y - p2.y }

#eval Point2.sub {x := 3.0, y := 4.0} {x := 1.0, y := 2.0}

#eval ({x := 3.0, y := 4.0}: Point2).sub {x := 1.0, y := 2.0} -- syntactic sugar to call a method

end Structure_4
./functional_programming/Test/Function_3.lean

namespace Function_3

-- function (or variable - anything is a function) without arguments
def hello: String := "world"

#eval hello

def lean: String := "Lean" -- with type

#eval lean

-- two ways to define a function
-- 1. using def
-- 2. using fun - lambda expression

def add2 (n: Nat): Nat := n + 2

def add3: Nat → Nat := fun n => n + 3

def add4: Nat → Nat := λ n => n + 4
def add5: Nat → Nat := ( · + 5 )
def add6: Nat → Nat := λ n ↦ n + 6

#eval [(add2 3), (add3 3), (add4 3), (add5 3)] -- will be list [5, 6, 7, 8]

-- two ways to define a function with two arguments
-- 1. using def
-- 2. using fun - lambda expression (curried function)

def mysum1 (a: Nat) (b: Nat): Nat := a + b
def mysum2: Nat → Nat → Nat := fun a b => a + b
def mysum3: Nat → Nat → Nat := fun a => fun b => a + b
def mysum4: Nat → Nat → Nat
  | a, b => a + b -- using pattern matching

#eval [(mysum1 3 4), (mysum2 3 4), (mysum3 3 4), (mysum4 3 4)] -- will be list [7, 7, 7, 7]

#check [mysum1, mysum2, mysum3, mysum4] -- check type

#check [mysum1 3, mysum2 3, mysum3 3, mysum4 3] -- check type




def Str1: Type := String -- type as first class citizen
def Str2: Type := String → String

def aStr: Str1 := "hello"
def aStr2: Str2 := fun (s : String) => (s ++ " world": String)
def aStr3: Str2 := λ (s : String) => (s ++ " world": String)

#eval aStr3 aStr -- will be "hello world"

abbrev N: Type := Nat -- type alias - recommended way

end Function_3
./functional_programming/Main.lean
import Test


def main : IO Unit :=
  IO.println s!"Hello, world!"
./functional_programming/Test.lean
-- This module serves as the root of the `Test` library.
-- Import modules here that should be built as part of the library.
import Test.Basic_1
import Test.Type_2
import Test.Function_3
import Test.Structure_4
import Test.Recursion_5
import Test.Polymorphism_6
import Test.Other_7
./theorem_proving/tactic/calculation_proof_for_transitivity.lean
-- calculation proof also works for inequalities or any transitive relation

section CalculationProofTransitive
  variable (a b c d : Nat)
  variable (h1 : a = b)
  variable (h2 : b ≤ c)
  variable (h3 : c + 1 < d)

  -- example using `calc` to show inequality
  example  : a < d :=
    calc
      a = b     := h1
      _ < b + 1 := Nat.lt_succ_self b -- `Nat.lt_succ_self a` gives a proof for `a < a + 1`
      _ ≤ c + 1 := Nat.succ_le_succ h2 -- `Nat.succ_le_succ` gives a proof for `n.succ ≤ m.succ` from `n ≤ m`
      _ < d     := h3


  -- `x` divides `y` as natural numbers
  def divides (x y : Nat) : Prop := ∃ k: Nat, k*x = y

  -- transitivity of `divides` - I don't understand this at the moment
  def divides_trans (h₁ : divides x y) (h₂ : divides y z) : divides x z :=
    have ⟨k₁, d₁⟩ := h₁ -- `k₁: Nat` and `d₁: k₁ * x = y` is a proof for `k₁ * x = y`
    have ⟨k₂, d₂⟩ := h₂ -- `k₂: Nat` and `d₂: k₂ * y = z` is a proof for `k₂ * y = z`
    ⟨k₁ * k₂, by rw [Nat.mul_comm k₁ k₂, Nat.mul_assoc, d₁, d₂]⟩

  -- `x` divides `k * x`
  def divides_mul (x : Nat) (k : Nat) : divides x (k*x) :=
    ⟨k, rfl⟩

  -- declaring `divides` as a transitive relation
  instance : Trans divides divides divides where
    trans := divides_trans

  -- example using `calc`
  example (h₁ : divides x y) (h₂ : y = z) : divides x (2*z) :=
    calc
      divides x y     := h₁
      _ = z           := h₂
      divides _ (2*z) := divides_mul ..
end CalculationProofTransitive
./theorem_proving/tactic/calculation_proof.lean


/-
Let `a` and `b` be any objects, then `a = b` is a proposition (also written as `Eq a b`). `Eq` admits several properties

- `Eq.refl`: Let `a` be any object, then `Eq.refl a: a = a` is a proof

- `Eq.symm`: Let `hab: a = b` be a proof, then `Eq.symm hab: b = a` is also a proof

- `Eq.trans`: Let `hab: a = b`, `hbc: b = c` be proofs, then `Eq.trans hab hbc: a = c` is also a proof


In proving equality, lean provides several substitution rules

- `Eq.subst`: Let `x: $\alpha$` and `y: $\alpha$`. Let `h: a = b` be a proof and `p: $\alpha \to$ Prop`, then if `hx: p x` is a proof, then `Eq:subst: p y` is also a proof

- `congrArg`: Let `x: $\alpha$` and `y: $\alpha$`. Let `h: a = b` be a proof and `f: $\alpha \to \beta$`, then `congrArg f h: f x = f y` is a proof

- `congrFun`: Let `f: $\alpha \to \beta$` and `g: $\alpha \to \beta$`. Let `h: f = g` and `x: $\alpha$`, then `congrFun h x: f x = g x` is a proof

- `congr`: Let `x: $\alpha$` and `y: $\alpha$`. Let `f: $\alpha \to \beta$` and `g: $\alpha \to \beta$`. Let `h\_1: x = y` and `h\_2: f = g`, then `congr h\_2 h\_1: f x = g y` is a proof
-/

section CalculationProof
  -- TODO: implement `Eq` as an inductive type


  variable (a b c d e: Nat)
  variable (h1: a = b)
  variable (h2: b = c + 1)
  variable (h3: c = d)
  variable (h4: e = 1 + d)

  -- example using `calc` to show equality
  example : a = e := by
  calc
    a = b := h1
    _ = c + 1 := h2
    _ = d + 1 := congrArg (λ x => x + 1) h3   -- `congrArg` is used to apply a function to both sides of an equation
    _ = 1 + d := Nat.add_comm d 1             -- `Nat.add_comm a b` gives a proof for `a + b = b + a`
    _ = e := Eq.symm h4

  -- example using `calc` to show equality with `rewrite` tactic
  example : a = e := by
  calc
    a = b := by rw [h1]
    _ = c + 1 := by rw [h2]
    _ = d + 1 := by rw [h3]
    _ = 1 + d := by rw [Nat.add_comm]
    _ = e := by rw [h4]

  -- example using `simp` tactic to simplify `calc` proof with `rewrite`
  example : a = e := by
    simp [h1, h2, h3, Nat.add_comm, h4]


end CalculationProof
./theorem_proving/tactic/tactic.lean
-- `Control-Shift-Enter` or `Command-Shift-Enter` to show `Lean InfoView`


-- easy example with `intro`
theorem t {p q: Prop} : p ∧ q → p ∨ q := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∨ q`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∨ q`
  apply Or.intro_left
  -- current goal: `case h ; p q : Prop ; h : p ∧ q ⊢ p`
  exact h.left
  -- current goal: no more goal - proof is complete

-- #print t -- print the proof generated by lean

-- a more complicated example
example {p q: Prop} : p ∧ q → p ∧ q ∧ p := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∧ q ∧ p`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∧ q ∧ p`
  apply And.intro
  -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ p`
  -- current goal 2: `case right ; p q : Prop ; h : p ∧ q ⊢ q ∧ p`
  case left => -- do `case left` first
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ p`
    exact h.left
  case right =>
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ q ∧ p`
    apply And.intro
    -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ q`
    -- current goal 2: `case right ; p q : Prop ; h: p ∧ q ⊢ p`
    case right => -- do `case right` first
      -- current goal: `p q : Prop ; h: p ∧ q ⊢ p`
      exact h.left
    case left =>
      -- current goal: `p q : Prop ; h : p ∧ q ⊢ q`
      exact h.right

-- introduce variables
example : ∀ a b c : Nat, a = b ∧ a = c → c = b := by
  intro a b c h -- `a b c : Nat ; h : a = b ∧ a = c`
  have h₁ := h.left
  have h₂ := h.right
  exact Eq.trans (Eq.symm h₂) h₁

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂ -- `a b c : Nat ; h₁ : a = b ; h₂ : a = c`
  exact Eq.trans (Eq.symm h₂) h₁

-- example for `intro` using `⟨ ... ⟩` constructor
example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩ -- `w` is a term that witnesses `p w ∧ q w`
  exact ⟨w, hqw, hpw⟩

-- example for `assumption`
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  -- current goal: `x y z w : Nat ;  h₁ : x = y ; h₂ : y = z ; h₃ : z = w`
  -- `assumption` automatically find the assumption to fulfill the goal
  assumption -- here it uses `h₃`

-- example for `intros` and `assumption`
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption

-- example for `intros`, `assumption`, and `repeat`
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  repeat assumption -- repeat assumption until goal is fulfilled

-- example for `revert` and `rfl`
example (x : Nat) : x = x := by
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  exact rfl -- `rfl` proves all `x ∼ x` for every reflexive relation `∼`


-- example for `generalize`
example : 3 = 3 := by
  generalize 3 = x
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  rfl


-- decompose a disjunction with `cases` (it is just `match`)
-- or more generally any inductive type
example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h -- `h : p ∨ q`
  -- current goal : `p q : Prop ; h : p ∨ q ⊢ q ∨ p`
  cases h with
  | inl hp =>
    -- current goal : `p q : Prop ; hp : p ⊢ q ∨ p`
    apply Or.inr; exact hp
  | inr hq =>
    -- current goal : `p q : Prop ; hq : q ⊢ q ∨ p`
    apply Or.inl; exact hq

-- decompose an existence by `cases`
-- prove for existence by `exists`
example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  -- current goal: `p q : Nat → Prop ; h : ∃ x, p x ⊢ ∃ x, p x ∨ q x`
  cases h with
  | intro w pw =>
    -- current goal: `p q : Nat → Prop ; w : Nat ; pw : p ; w ⊢ ∃ x, p x ∨ q x`
    exists w -- tell `lean` that `w` is the chosen point to satisfy existential goal
    -- current goal: `p q : Nat → Prop ; w : Nat ; pw : p w ⊢ p w ∨ q w`
    apply Or.inl
    exact pw


-- proof by contradiction
example (p q : Prop) : p ∧ ¬p → q := by
  intro h
  have h₁ := h.left
  have h₂ := h.right
  contradiction -- search for contradiction

-- proof by contradiction
example (p q : Prop) : p ∧ ¬p → q := by
  intro h
  cases h -- created `left: p` and `right: p` automatically
  contradiction

-- mixed term-mode and tactic-mode
example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) :=
  by -- start tactic mode by `by`
  intro h
  exact -- start term mode by `exact`
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by -- start tactic mode by `by`, `show (p ∧ q) ∨ (p ∧ r)` is optional
      cases hqr with
      | inl hq => exact Or.inl ⟨hp, hq⟩
      | inr hr => exact Or.inr ⟨hp, hr⟩

-- optional `show`
example {p q: Prop} : p ∧ q → q ∧ p := by
  intro h
  apply And.intro
  case left =>
    show q -- use show to specify which goal we are resolving
    exact h.right
  case right =>
    show p -- use show to specify which goal we are resolving
    exact h.left


-- alternative to proving multiple goals
/-
  apply foo
  . <proof of first goal>
  . <proof of second goal>
  . <proof of third goal>
  . <proof of final goal>

  apply foo
  case <tag of first goal>  => <proof of first goal>
  case <tag of second goal> => <proof of second goal>
  case <tag of third goal>  => <proof of third goal>
  case <tag of final goal>  => <proof of final goal>

  apply foo
  { <proof of first goal>  }
  { <proof of second goal> }
  { <proof of third goal>  }
  { <proof of final goal>  }
-/

-- anther example
-- this is my favorite way to prove: mixed tactic mode term mode
-- just make a sequence of true statments
-- a → b → c → d
-- occasionally I use calc proof
example (f : Nat → Nat) (a : Nat) : a + 0 = 0 → f a = f 0 := by
  intro h₀
  have h₁ : a = 0 := by
    calc
      a = a + 0 := by rw [Nat.add_zero]
      _ = 0 := by rw [h₀]
  have h₂ : f a = f 0 := congrArg f h₁
  exact h₂

-- `rw [...] at ...` - rewrite in hypothesis instead of goal
example (f : Nat → Nat) (a : Nat) : a + 0 = 0 → f a = f 0 := by
  intro h
  rw [Nat.add_zero] at h
  rw [h]

-- the rest will do later - TODO
./theorem_proving/tactic/auxiliary_subgoals.lean
section
  -- subgoal example 1
  example {p q: Prop} (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left           -- same as let `hp := And.left h`
  have hq : q := h.right          -- same as let `hq := And.right h`
  show q ∧ p from And.intro hq hp -- same as `And.intro hq hp`

  -- subgoal example 2
  example {p q: Prop} (h : p ∧ q) : q ∧ p :=
  have hp : p := h.left           -- same as let `hp := And.left h`
  -- instead of showing `hq: q`, we assume `hq: q` and show `And.intro hq hp: q ∧ p` first
  suffices hq : q from And.intro hq hp
  show q from And.right h         -- now we show `hq: q`
end
./theorem_proving/type_theory/inductive_type.lean
namespace InductiveType

/-
Inductive type is a very powerful notion that can be generalize greatly. Any inductive type is constructed as follows:

inductive Foo where
  | constructor₁ : ... → Foo
  | constructor₂ : ... → Foo
  ...
  | constructorₙ : ... → Foo

Below are some examples of inductive types
-/


-- finite list of terms
inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday


-- `Bool` is defined by
inductive Bool where
  | false : Bool
  | true  : Bool

-- use match to process each constructor separately
def and (a b: Bool): Bool :=
  match a with
    | Bool.true => b
    | Bool.false => Bool.false

-- type can have arguments
-- `Prod α β ≡ α × β`, `Prod.mk a b ≡ (a, b)`
inductive Prod (α : Type u) (β : Type v) where
  | mk : α → β → Prod α β

-- `Sum α β ≡ α ⊕ β`
inductive Sum (α : Type u) (β : Type v) where
  | inl : α → Sum α β
  | inr : β → Sum α β


-- `And` and `Or` are actually `Prod` and `Sum`
-- `And a b ≡ a ∧ b`, `Or a b ≡ a ∨ b`

-- proof by `cases`
example: (a ∨ b) → (b ∨ a) := by
  intro h
  cases h with
    | inl ha => exact Or.inr ha
    | inr hb => exact Or.inl hb


-- `structure` is actually product type
-- `Color1 ≡ Color2`
inductive Color1 where
  | mk (red: Nat) (green: Nat) (blue: Nat): Color1

structure Color2 where
  red: Nat
  green: Nat
  blue: Nat



-- more complex examples with type dependent
inductive Option (α : Type u) where
  | none : Option α
  | some : α → Option α

inductive Inhabited (α : Type u) where
  | mk : α → Inhabited α

def option_nat_none : Option Nat := Option.none
def inhatbited_nat_2 : Inhabited Nat := Inhabited.mk 2

-- natural numbers
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat

-- `add` inductively
def add (x : Nat) (y: Nat) : Nat :=
  match y with
  | Nat.zero   => x
  | Nat.succ z => Nat.succ (add x z)

-- proof by (weak) `induction` for `0 + y = y`
theorem add_zero: (y: Nat) → add Nat.zero y = y := by
  intro y
  -- similar to `cases ` but `induction` gives `ih: add Nat.zero z = z`
  induction y with
    | zero => rfl
    | succ z ih =>
      calc
        add Nat.zero (Nat.succ z) = Nat.succ (add Nat.zero z) := by rfl
        _ = Nat.succ z := by rw [ih]

end InductiveType


section StrongInduction
def is_prime : Nat →  Prop := by
  intro n
  exact (n ≥ 2) ∧ (∀ (m: Nat), m ∣ n → m = 1 ∨ m = n)

theorem prime_decomposition: ∀ (n: Nat), (n ≥ 2) → (is_prime n) ∨ (∃ (m: Nat), (is_prime m) ∧ (m ∣ n)) := by
  intro n -- `n: Nat`
  intro h₁ -- `h₁: n ≥ 2`
  by_cases h₂ : is_prime n
  case pos =>
    -- `h₂: is_prime n` is true
    exact Or.inl h₂
  case neg =>
    -- h₂: `¬is_prime n`
    -- Now show ∃ m, is_prime m ∧ m ∣ n
    sorry





end StrongInduction
./theorem_proving/type_theory/predicate_logic.lean
/-
`Prop` is an object at `universe level 1` which is at the same level with `Nat` or `String`. A term of `universe Prop` is called a `proposition`, e.g. `1 + 1 = 3`, `True`, `Fermat's last theorem`

Curry-Howard (CH) asserts that there is an correspondence between mathematical proofs and computer programs. In that correspondence, a mathematical statement is a `proposition` and proving for a mathematical statement is constructing a term for the corresponding `proposition`.

If `hp: p` is a term of proposition `p: Prop`, then we say the truth of `p` is witnessed by `hp` or `hp` is a proof/certificate for the truth of `p`

A proposition `p: Prop` is `inhabited` if and only if it is true.
-/

-- some basic propositions




namespace PredicateLogic

-- `False` is an uninhabited type i.e. there is no proof for `False`
-- `False` implies everything
inductive False
def False.elim {q: Sort u} : (h : False) → q :=
  λ h ↦ nomatch h
example: False → 2 + 2 = 5 := by
  intro h
  exact False.elim h

-- `True` is an inhabited type with a single constructor
-- `trivial` is short for `True.intro`
inductive True where
  | intro : True


-- `Implies p q` is actually `p → q` by `CH`
-- `Implies.elim` proves `q` from `hpq: Implies p q` and `hp: p`
inductive Implies (p: Sort u) (q: Sort v) where
  | intro : (p → q) → Implies p q

def Implies.elim {p: Sort u} {q: Sort v}: Implies p q → p → q := by
  intro hpq hp
  match hpq with
    | intro hpq => exact hpq hp

-- `And p q` also written as `p ∧ q`
-- `And` takes in a pair of proofs for `p` and `q`
-- `And.left` `And.right` extract the proof for `p` and `q`
inductive And (p: Sort u) (q: Sort v) where
  | intro : p → q → And p q

def And.left: And p q → p := by
  intro h
  cases h with
  | intro hp _ => exact hp

def And.right:  And p q → q := by
  intro h
  cases h with
  | intro _ hq => exact hq

-- `Or p q` also written as `p ∨ q`
-- `Or` takes in either proof for `p` or `q`
-- `Or.elim` proves `r` from `p ∨ q`, `p → r` and `q → r`
inductive Or (p: Sort u) (q: Sort v) where
  | inl : p → Or p q
  | inr : q → Or p q

def Or.elim: Or p q → (p → r) → (q → r) → r := by
  intro h hpr hqr
  cases h with
  | inl hp => exact hpr hp
  | inr hq => exact hqr hq

-- `Not p` is actually `p → False`
-- `Not.elim` proves `False` from `hp: p`
inductive Not (p: Sort u) where
  | intro: (p → False) → Not p

def Not.elim: Not p → p → False := by
  intro h hp
  cases h with
  | intro hnp => exact hnp hp

-- `Iff p q` also written as `p ↔ q`
-- `Iff` takes in `p → q` and `q → p`
-- `Iff.mp` and `Iff.mpr` extract the proof for `p → q` and `q → p`
inductive Iff (p: Sort u) (q: Sort v) where
  | intro: (p → q) → (q → p) → Iff p q

def Iff.mp: Iff p q → Implies p q := by
  intro h
  cases h with
    | intro hpq _ => exact Implies.intro hpq

def Iff.mpr: Iff p q → Implies q p := by
  intro h
  cases h with
    | intro _ hqp => exact Implies.intro hqp

-- `Forall` also written as `∀ (a: α), p a`
-- `Forall.elim h a` proves `p a` from `h: Forall α p` and `a: α`
inductive Forall (α: Sort u) (p: α → Sort v) where
  | intro : ((a: α) → p a) → Forall α p

def Forall.elim: Forall α p → (a: α) → p a := by
  intro h a
  match h with
  | intro hap => exact hap a

-- `Exists` also written as `∃ (a: α), p a`
-- `Exists` is constructed from `a: α` and `p a: Prop`
inductive Exists (α: Sort u) (p: α → Sort v)  where
  | intro : (a: α) → (ha: p a) → Exists α p

def Exists.elim: Exists α p → Forall α (λ a => p a → q) → q := by
  intro h hpq
  match h with
  | Exists.intro a ha => exact (Forall.elim hpq a) ha

-- Law of excluded middle
axiom EM : Forall (Sort u) (λ (p: Sort u) ↦ (Or p (Not p)))

end PredicateLogic
./theorem_proving/type_theory/dependent_type_theory.lean
namespace DependentTypeTheory

/-
BASIC DEPENDENT TYPE THEORY

Consider the set of all formal strings `S` and the sematic equivalence relation `∼` on `S`. For example, `λ (x: Nat) → x + 4` and `fun (y: Nat) => y + 4` are two different strings but have the same semantic. We will use the same word `object` for both syntactic string and its meaning without confusion

In lean, every object longs to a `universe level`, below are some examples

- `universe level -1`: proofs
- `universe level 0`: `1`, `-2`, `1.4`, `"hello word"`, `λ (x: Nat) → x + 4`
- `universe level 1`: `Nat`, `Int`, `Float`, `String`, `Nat → Nat`
- `universe level 2`: `Type` (aka `Type 0` or `Sort 1`)
- `universe level 3`: `Type 1` (aka `Sort 2`)
- ...

Moreover, every object has a type, that is a function `t` that maps object from `universe level n` to `universe level n+1`. In programming, this is called getting type of (`type` in Python, `typeof` in Javascript). For example, `t(1) = Nat`, `t(true) = Bool`, `t(λ (x: Nat) => x + 4) = Nat → Nat`.

Let `α` be any object at `universe level n+1`, the collection of all objects in `universe level n` of type `α` is called the `universe α`. For example, `universe Nat` consists of of all natural numbers. We write `x : Nat` to denote `x` is of type `Nat` and `x` is called a `term` (or `element` of `Nat`).

A type is said to be `inhabited` if it has at least one term and `uninhabited` if it has no term.

In lean, `t` is not exposed to user. However, during compilation process, lean allows user to print value and type of an object using `#eval` and `#check`
-/

-- #eval 20
-- #check 20

/-
ARROW TYPE

If `α` and `β` are two objects at `universe level n` and `universe level m` respectively, then `α → β` is an object at `universe level max(n, m)`. We will call it `arrow type`. when `f` is of arrow type `α → β`, we write `f : α → β` (or `(a: α) → β` like function in programming)

Moreover, lean allows user to define dependent type, for example `g: (α: Type) → (b: β) → γ α b` where `γ α b` is another object. A more concrete example is `make_vector (α: Type) (n: Nat): Vector α n` which is a function creating a vector of dimension `n` of type `α`
-/

inductive Vector (α : Type u) : Nat → Type u
| nil  : Vector α 0
| cons {n: Nat} : α → Vector α n → Vector α (n + 1)

-- let α be Inhabited, i.e. there is at least 1 term, namely default
def make_vector (α: Type) [s: Inhabited α] (n: Nat): Vector α n :=
  match n with
  | 0 => Vector.nil
  | m+1 => Vector.cons s.default (make_vector α m)

end DependentTypeTheory
./theorem_proving/Main.lean
-- the import order is also the reading order
import type_theory.dependent_type_theory
import type_theory.inductive_type
import type_theory.predicate_logic

import tactic.calculation_proof
import tactic.calculation_proof_for_transitivity
import tactic.auxiliary_subgoals
import tactic.tactic


def main : IO Unit :=
  IO.println s!"Hello, World!"
do you have any comment on this?

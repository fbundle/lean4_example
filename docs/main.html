<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title> Theorem Proving in Lean 4
this document contains my notes when learning lean 4. the main references for this are [4], and [3]
</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)"> 
<meta name="originator" content="TeX4ht (https://tug.org/tex4ht/)"> 
<!-- html --> 
<meta name="src" content="main.tex"> 
<link rel="stylesheet" type="text/css" href="main.css"> 
</head><body 
>
<div class="maketitle">
                                                                                               
                                                                                               

<h2 class="titleHead"> Theorem Proving in Lean 4<br />
 this document contains my notes when learning lean 4. the main references for this are [<a 
href="#XLuisWirth">4</a>], and [<a 
href="#XJeremy">3</a>]  </h2>
 <div class="author" ><span 
class="ec-lmss-12">Nguyen Ngoc Khanh</span></div><br />
<div class="date" ><span 
class="ec-lmss-12">May 9, 2025</span></div>
                                                                                               
                                                                                               
</div>
                                                                                               
                                                                                               
<h2 class="likechapterHead"><a 
 id="x1-1000"></a>Contents</h2>
<div class="tableofcontents">
<span class="chapterToc" >0 <a 
href="#x1-20000" id="QQ2-1-2">PREREQUISITES</a></span>
<br /><span class="chapterToc" >1 <a 
href="#x1-30001" id="QQ2-1-3">DEPENDENT TYPE THEORY</a></span>
<br /><span class="sectionToc" >1.1 <a 
href="#x1-40001.1" id="QQ2-1-4">SUM, PRODUCT, AND HOM</a></span>
<br /><span class="chapterToc" >2 <a 
href="#x1-50002" id="QQ2-1-5">PREDICATE LOGIC</a></span>
<br /><span class="sectionToc" >2.1 <a 
href="#x1-60002.1" id="QQ2-1-6">TRUE</a></span>
<br /><span class="sectionToc" >2.2 <a 
href="#x1-70002.2" id="QQ2-1-7">FALSE</a></span>
<br /><span class="sectionToc" >2.3 <a 
href="#x1-80002.3" id="QQ2-1-8">IMPLICATION <span 
class="lmsy-10">&#x2192;</span></a></span>
<br /><span class="sectionToc" >2.4 <a 
href="#x1-90002.4" id="QQ2-1-9">CONJUNCTION <span 
class="lmsy-10">&#x2227;</span></a></span>
<br /><span class="sectionToc" >2.5 <a 
href="#x1-100002.5" id="QQ2-1-10">DISJUNCTION <span 
class="lmsy-10">&#x2228;</span></a></span>
<br /><span class="sectionToc" >2.6 <a 
href="#x1-110002.6" id="QQ2-1-11">NEGATION <span 
class="lmsy-10">¬</span></a></span>
<br /><span class="sectionToc" >2.7 <a 
href="#x1-120002.7" id="QQ2-1-12">LOGICAL EQUIVALENCE <span 
class="lmsy-10">&#x2194;</span></a></span>
<br /><span class="sectionToc" >2.8 <a 
href="#x1-130002.8" id="QQ2-1-13">UNIVERSAL QUANTIFIER <span 
class="lmsy-10">&#x2200;</span></a></span>
<br /><span class="sectionToc" >2.9 <a 
href="#x1-140002.9" id="QQ2-1-14">EXISTENTIAL QUANTIFIER <span 
class="lmsy-10">&#x2203;</span></a></span>
<br /><span class="sectionToc" >2.10 <a 
href="#x1-150002.10" id="QQ2-1-15">CLASSICAL LOGIC</a></span>
<br /><span class="sectionToc" >2.11 <a 
href="#x1-160002.11" id="QQ2-1-16">AUXILIARY SUBGOALS</a></span>
<br /><span class="chapterToc" >3 <a 
href="#x1-170003" id="QQ2-1-17">EQUALITY: CALCULATION PROOF</a></span>
<br /><span class="sectionToc" >3.1 <a 
href="#x1-180003.1" id="QQ2-1-18">EQUALITY</a></span>
<br /><span class="sectionToc" >3.2 <a 
href="#x1-190003.2" id="QQ2-1-19">CALCULATION PROOF - REWRITE TACTIC</a></span>
<br /><span class="sectionToc" >3.3 <a 
href="#x1-200003.3" id="QQ2-1-20">TRANSITIVITY AND CALCULATION PROOF</a></span>
<br /><span class="chapterToc" >4 <a 
href="#x1-210004" id="QQ2-1-21">TACTIC: LEAN AS A THEOREM PROVER</a></span>
<br /><span class="chapterToc" >5 <a 
href="#x1-220005" id="QQ2-1-22">PROOF BY INDUCTION: THE NATURAL NUMBERS</a></span>
</div>
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;0</span><br /><a 
 id="x1-20000"></a>PREREQUISITES</h2>
<!--l. 3--><p class="noindent" >Before reading this, we assume that readers are familiar with Lean 4 programming basics. It should be sufficient by reading the
first chapter of [<a 
href="#XDavidThraneChristiansen">1</a>]
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;1</span><br /><a 
 id="x1-30001"></a>DEPENDENT TYPE THEORY</h2>
<!--l. 3--><p class="noindent" >Keywords: <span 
class="ec-lmsso-10">object</span>, <span 
class="ec-lmsso-10">universe level</span>, <span 
class="ec-lmsso-10">universe</span>, <span 
class="ec-lmsso-10">term</span>, <span 
class="ec-lmsso-10">element</span>
<!--l. 5--><p class="noindent" >Consider the set of all formal strings <span 
class="lmmi-10">S </span>and the semantic equivalence relation <span 
class="lmsy-10">~ </span>on <span 
class="lmmi-10">S</span>. For example, <span class="texthl"><span id="textcolor1"><span 
class="lmmi-10">&#x03BB; </span>(x: Nat) =&#x003E; x + 4</span></span> and <span class="texthl"><span id="textcolor2">fun
(y: Nat) =&#x003E; y+4</span></span> are two different strings but have the same meaning/semantic. We will use the same word <span 
class="ec-lmsso-10">object </span>for both
syntactic string and its meaning without confusion.
<!--l. 7--><p class="noindent" >In lean, every object belongs to a <span 
class="ec-lmsso-10">universe level</span>, below are some examples
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 10--><p class="noindent" >universe level -1: proofs
     </li>
     <li class="itemize">
     <!--l. 11--><p class="noindent" >universe level 0: <span class="texthl"><span id="textcolor3">1</span></span>, <span class="texthl"><span id="textcolor4">-2</span></span>, <span class="texthl"><span id="textcolor5">1.5</span></span>, <span class="texthl"><span id="textcolor6">"hello world"</span></span>, <span class="texthl"><span id="textcolor7">true</span></span>, <span class="texthl"><span id="textcolor8"><span 
class="lmmi-10">&#x03BB; </span>(x: Nat) =&#x003E; x + 4</span></span>
     </li>
     <li class="itemize">
     <!--l. 12--><p class="noindent" >universe level 1: <span class="texthl"><span id="textcolor9">Nat</span></span>, <span class="texthl"><span id="textcolor10">Int</span></span>, <span class="texthl"><span id="textcolor11">Float</span></span>, <span class="texthl"><span id="textcolor12">String</span></span>, <span class="texthl"><span id="textcolor13">Bool</span></span>, <span class="texthl"><span id="textcolor14">Nat <span 
class="lmsy-10">&#x2192; </span>Nat</span></span>
     </li>
     <li class="itemize">
     <!--l. 13--><p class="noindent" >universe level 2: <span class="texthl"><span id="textcolor15">Type</span></span> (aka <span class="texthl"><span id="textcolor16">Type 0</span></span>)
     </li>
     <li class="itemize">
     <!--l. 14--><p class="noindent" >universe level 3: <span class="texthl"><span id="textcolor17">Type 1</span></span>
     </li>
     <li class="itemize">
     <!--l. 15--><p class="noindent" >universe level 4: ...</li></ul>
<!--l. 18--><p class="noindent" >Moreover, every object has a type, that is a function <span class="texthl"><span id="textcolor18">t</span></span> that maps object from universe level <span 
class="lmmi-10">n </span>to universe level <span 
class="lmmi-10">n </span><span 
class="rm-lmr-10">+ 1</span>. In
programming, this is called getting type of (<span class="texthl"><span id="textcolor19">type</span></span> in Python, <span class="texthl"><span id="textcolor20">typeof</span></span> in Javascript). For example, <span class="texthl"><span id="textcolor21">t(1) = Nat</span></span>, <span class="texthl"><span id="textcolor22">t(true) = Bool</span></span>, <span class="texthl"><span id="textcolor23">t(<span 
class="lmmi-10">&#x03BB;</span>
(x: Nat) =&#x003E; x + 4) = Nat <span 
class="lmsy-10">&#x2192; </span>Nat</span></span>. Let <span class="texthl"><span id="textcolor24"><span 
class="lmmi-10">&#x03B1;</span></span></span> be any object at level <span 
class="lmmi-10">n</span>, the collection of all objects of type <span class="texthl"><span id="textcolor25"><span 
class="lmmi-10">&#x03B1;</span></span></span> is called the <span 
class="ec-lmsso-10">universe </span><span class="texthl"><span id="textcolor26"><span 
class="lmmi-10">&#x03B1;</span></span></span>.
For example, universe <span class="texthl"><span id="textcolor27">Nat</span></span> consists of of all natural numbers. We write <span class="texthl"><span id="textcolor28">x: Nat</span></span> to denote <span class="texthl"><span id="textcolor29">x</span></span> is of type <span class="texthl"><span id="textcolor30">Nat</span></span> and <span class="texthl"><span id="textcolor31">x</span></span> is called a <span 
class="ec-lmsso-10">term </span>(or
<span 
class="ec-lmsso-10">element</span>) of <span class="texthl"><span id="textcolor32">Nat</span></span>
<!--l. 20--><p class="noindent" >In lean, <span 
class="lmmi-10">t </span>is not exposed to user. However, during compilation process, lean allows user to print value and type of an object using
<span class="texthl"><span id="textcolor33">#eval</span></span> and <span class="texthl"><span id="textcolor34">#check</span></span>
<h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-40001.1"></a>SUM, PRODUCT, AND HOM</h3>
<!--l. 24--><p class="noindent" >Let <span class="texthl"><span id="textcolor35"><span 
class="lmmi-10">&#x03B1;</span></span></span> <span class="texthl"><span id="textcolor36"><span 
class="lmmi-10">&#x03B2;</span></span></span> be objects at level <span 
class="lmmi-10">n,m </span>respectively. Then <span class="texthl"><span id="textcolor37"><span 
class="lmmi-10">&#x03B1;</span><span 
class="lmsy-10">&#x2295;</span><span 
class="lmmi-10">&#x03B2;</span></span></span>, <span class="texthl"><span id="textcolor38"><span 
class="lmmi-10">&#x03B1;</span><span 
class="lmsy-10">&#x00D7;</span><span 
class="lmmi-10">&#x03B2;</span></span></span>, and <span class="texthl"><span id="textcolor39"><span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> are objects at level <span 
class="rm-lmr-10">max</span><span 
class="rm-lmr-10">(</span><span 
class="lmmi-10">n,m</span><span 
class="rm-lmr-10">) </span>which are called sum
(coproduct, union), product (Cartesian product), and hom.
<!--l. 26--><p class="noindent" >The universe <span class="texthl"><span id="textcolor40"><span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2295;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> consists of all elements from <span class="texthl"><span id="textcolor41"><span 
class="lmmi-10">&#x03B1;</span></span></span> and <span class="texthl"><span id="textcolor42"><span 
class="lmmi-10">&#x03B2;</span></span></span>
<!--l. 28--><p class="noindent" >The universe <span class="texthl"><span id="textcolor43"><span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x00D7;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> consists of all pair <span class="texthl"><span id="textcolor44"><span 
class="rm-lmr-10">(</span><span 
class="lmmi-10">a,b</span><span 
class="rm-lmr-10">)</span></span></span> where <span class="texthl"><span id="textcolor45"><span 
class="lmmi-10">a</span></span></span> is an element of <span class="texthl"><span id="textcolor46"><span 
class="lmmi-10">&#x03B1;</span></span></span> and <span class="texthl"><span id="textcolor47"><span 
class="lmmi-10">b</span></span></span> is an element of <span class="texthl"><span id="textcolor48"><span 
class="lmmi-10">&#x03B2;</span></span></span>
<!--l. 30--><p class="noindent" >The universe <span class="texthl"><span id="textcolor49"><span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> consists of all functions mapping elements of <span class="texthl"><span id="textcolor50"><span 
class="lmmi-10">&#x03B1;</span></span></span> to elements of <span class="texthl"><span id="textcolor51"><span 
class="lmmi-10">&#x03B2;</span></span></span>
                                                                                               
                                                                                               
<!--l. 35--><p class="noindent" ><span id="textcolor52"><span 
class="ec-lmsso-10">I don&#8217;t understand the internal working of types, but this is my theory on how to make senses of different level sum/product/hom</span>
<span 
class="ec-lmsso-10">types. </span><span class="texthl"><span id="textcolor53"><span 
class="ec-lmsso-10">2</span></span></span> <span 
class="ec-lmsso-10">is at level 0 and </span><span class="texthl"><span id="textcolor54"><span 
class="ec-lmsso-10">Nat</span></span></span> <span 
class="ec-lmsso-10">is at level 1, one can lift </span><span class="texthl"><span id="textcolor55"><span 
class="ec-lmsso-10">2</span></span></span> <span 
class="ec-lmsso-10">into level 1 into a new type </span><span class="texthl"><span id="textcolor56"><span 
class="ec-lmsso-10">Two</span></span></span> <span 
class="ec-lmsso-10">which has only one term </span><span class="texthl"><span id="textcolor57"><span 
class="ec-lmsso-10">2</span></span></span><span 
class="ec-lmsso-10">, then we can</span>
<span 
class="ec-lmsso-10">define </span><span class="texthl"><span id="textcolor58"><span 
class="ec-lmsso-10">2 </span><span 
class="lmsy-10">&#x00D7; </span><span 
class="ec-lmsso-10">Nat</span></span></span> <span 
class="ec-lmsso-10">by </span><span class="texthl"><span id="textcolor59"><span 
class="ec-lmsso-10">Two </span><span 
class="lmsy-10">&#x00D7; </span><span 
class="ec-lmsso-10">Nat</span></span></span><span 
class="ec-lmsso-10">. Similarly, one can lift </span><span class="texthl"><span id="textcolor60"><span 
class="ec-lmsso-10">Nat</span></span></span> <span 
class="ec-lmsso-10">into level 2 and lift every natural number into level 1.</span>
</span>
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;2</span><br /><a 
 id="x1-50002"></a>PREDICATE LOGIC</h2>
<!--l. 3--><p class="noindent" >Keywords: <span class="texthl"><span id="textcolor61">Prop</span></span>, CH, <span 
class="ec-lmsso-10">witnessed</span>, <span 
class="ec-lmsso-10">proof</span>, <span 
class="ec-lmsso-10">certificate</span>, <span 
class="ec-lmsso-10">inhabited</span>, <span 
class="ec-lmsso-10">uninhabited</span>, <span 
class="ec-lmsso-10">introduction rule</span>, <span 
class="ec-lmsso-10">elimination rule</span>
<!--l. 5--><p class="noindent" ><span class="texthl"><span id="textcolor62">Prop</span></span> is an object at level 1 which is the same level with <span class="texthl"><span id="textcolor63">Nat</span></span>. An element (level 0) of universe <span class="texthl"><span id="textcolor64">Prop</span></span> is called a proposition. For
example, <span class="texthl"><span id="textcolor65">True</span></span>, <span class="texthl"><span id="textcolor66">1 + 1 = 3</span></span>, <span class="texthl"><span id="textcolor67">Fermat&#8217;s last theorem</span></span>.
<!--l. 7--><p class="noindent" >Curry&#8211;Howard (CH) [<a 
href="#XCH">2</a>] asserts that proving a proposition <span class="texthl"><span id="textcolor68">p: Prop</span></span> is equivalent to constructing an element <span class="texthl"><span id="textcolor69">x: p</span></span> at level -1. Hence,
a proposition <span class="texthl"><span id="textcolor70">p: Prop</span></span> is said to be true if and only if there exists an element <span class="texthl"><span id="textcolor71">x: p</span></span> at level -1, we say that the truth of <span class="texthl"><span id="textcolor72">p: Prop</span></span> is
<span 
class="ec-lmsso-10">witnessed </span>by <span 
class="ec-lmsso-10">proof  </span><span class="texthl"><span id="textcolor73">x: p</span></span> or <span class="texthl"><span id="textcolor74">x: p</span></span> is a <span 
class="ec-lmsso-10">certificate </span>for the truth of <span class="texthl"><span id="textcolor75">p: Prop</span></span>.
<!--l. 9--><p class="noindent" >We say <span class="texthl"><span id="textcolor76">p: Prop</span></span> is <span 
class="ec-lmsso-10">inhabited </span>if there is a proof for <span class="texthl"><span id="textcolor77">p: Prop</span></span>, <span class="texthl"><span id="textcolor78">p: Prop</span></span> is <span 
class="ec-lmsso-10">uninhabited </span>if there is no proof for <span class="texthl"><span id="textcolor79">p: Prop</span></span>
<!--l. 11--><p class="noindent" >The type system in lean is powerful enough to model predicate logic, we will describe below the builtin logical connectives and
related <span 
class="ec-lmsso-10">introduction rules </span>and <span 
class="ec-lmsso-10">elimination rules</span>. An introduction rule is a way to prove <span class="texthl"><span id="textcolor80">p: Prop</span></span> from something else, an
elimination rule is a way deduce something else from <span class="texthl"><span id="textcolor81">p: Prop</span></span>
<h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-60002.1"></a>TRUE</h3>
<!--l. 15--><p class="noindent" ><span class="texthl"><span id="textcolor82">True: Prop</span></span> is a proposition.
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 18--><p class="noindent" ><span class="texthl"><span id="textcolor83">True</span></span> admits one introduction rule: <span class="texthl"><span id="textcolor84">True.intro: True</span></span> (also written as <span class="texthl"><span id="textcolor85">trivial: True</span></span>)
     </li>
     <li class="itemize">
     <!--l. 20--><p class="noindent" ><span class="texthl"><span id="textcolor86">True</span></span> admits no elimination rule, that is, one cannot use <span class="texthl"><span id="textcolor87">True</span></span> to prove anything</li></ul>
<!--l. 24--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-70002.2"></a>FALSE</h3>
<!--l. 26--><p class="noindent" ><span class="texthl"><span id="textcolor88">False: Prop</span></span> is a proposition in lean.
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 29--><p class="noindent" ><span class="texthl"><span id="textcolor89">False</span></span> admits no introduction rule, that is one cannot prove <span class="texthl"><span id="textcolor90">False</span></span>
     </li>
     <li class="itemize">
     <!--l. 31--><p class="noindent" ><span class="texthl"><span id="textcolor91">False</span></span> admits one elimination rule: <span class="texthl"><span id="textcolor92">False.elim</span></span>
     <!--l. 33--><p class="noindent" >that is, one can prove everything from <span class="texthl"><span id="textcolor93">False</span></span>. Let <span class="texthl"><span id="textcolor94">q: Prop</span></span> be a proposition, then <span class="texthl"><span id="textcolor95">False.elim q: q</span></span> is a proof</li></ul>
<!--l. 36--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-80002.3"></a>IMPLICATION <span 
class="lmsy-10">&#x2192;</span></h3>
                                                                                               
                                                                                               
<!--l. 38--><p class="noindent" >Let <span class="texthl"><span id="textcolor96">p: Prop</span></span> and <span class="texthl"><span id="textcolor97">q: Prop</span></span> be propositions and <span class="texthl"><span id="textcolor98">f: p <span 
class="lmsy-10">&#x2192; </span>q</span></span> be a map. If <span class="texthl"><span id="textcolor99">hp: p</span></span> is a proof, then <span class="texthl"><span id="textcolor100">f hp: q</span></span> is also a proof. This is known as
<span 
class="ec-lmsso-10">modus ponens </span>or implication elimination rule. In lean, <span class="texthl"><span id="textcolor101">p <span 
class="lmsy-10">&#x2192; </span>q: Prop</span></span> is a proposition. The introduction rules and elimination rules
are then obvious from the context.
<!--l. 40--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.4   </span> <a 
 id="x1-90002.4"></a>CONJUNCTION <span 
class="lmsy-10">&#x2227;</span></h3>
<!--l. 42--><p class="noindent" >Let <span class="texthl"><span id="textcolor102">p: Prop</span></span> and <span class="texthl"><span id="textcolor103">q: Prop</span></span> be propositions, then <span class="texthl"><span id="textcolor104">p <span 
class="lmsy-10">&#x2227; </span>q: Prop</span></span> is a proposition (also written as <span class="texthl"><span id="textcolor105">And p q</span></span> or <span class="texthl"><span id="textcolor106">p <span 
class="lmsy-10">&#x00D7; </span>q</span></span>)
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 45--><p class="noindent" ><span class="texthl"><span id="textcolor107">And</span></span> admits an and-introduction rule: <span class="texthl"><span id="textcolor108">And.intro</span></span>
     <!--l. 47--><p class="noindent" >Let <span class="texthl"><span id="textcolor109">hp: p</span></span> and <span class="texthl"><span id="textcolor110">hq: q</span></span> be a proofs, then <span class="texthl"><span id="textcolor111">And.intro hp hq: p <span 
class="lmsy-10">&#x2227; </span>q</span></span> is also a proof
     </li>
     <li class="itemize">
     <!--l. 49--><p class="noindent" ><span class="texthl"><span id="textcolor112">And</span></span> admits two and-elimination rules: <span class="texthl"><span id="textcolor113">And.left</span></span> and <span class="texthl"><span id="textcolor114">And.right</span></span>
     <!--l. 51--><p class="noindent" >Let <span class="texthl"><span id="textcolor115">h: p <span 
class="lmsy-10">&#x2227; </span>q</span></span> be a proof, then <span class="texthl"><span id="textcolor116">And.left h: p</span></span> and <span class="texthl"><span id="textcolor117">And.right h: q</span></span> are also proofs (also written as <span class="texthl"><span id="textcolor118">h.left</span></span> and <span class="texthl"><span id="textcolor119">h.right</span></span>)</li></ul>
<!--l. 55--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
 id="x1-100002.5"></a>DISJUNCTION <span 
class="lmsy-10">&#x2228;</span></h3>
<!--l. 57--><p class="noindent" >Let <span class="texthl"><span id="textcolor120">p: Prop</span></span> and <span class="texthl"><span id="textcolor121">q: Prop</span></span> be propositions, then <span class="texthl"><span id="textcolor122">p <span 
class="lmsy-10">&#x2228; </span>q: Prop</span></span> is a proposition (also written as <span class="texthl"><span id="textcolor123">Or p q</span></span> or <span class="texthl"><span id="textcolor124">p <span 
class="lmsy-10">&#x2295; </span>q</span></span>)
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 60--><p class="noindent" ><span class="texthl"><span id="textcolor125">Or</span></span> admits two or-introduction rules: <span class="texthl"><span id="textcolor126">Or.intro_left</span></span>, <span class="texthl"><span id="textcolor127">Or.intro_right</span></span>
     <!--l. 62--><p class="noindent" >Let <span class="texthl"><span id="textcolor128">hp: p</span></span> be a proof, then <span class="texthl"><span id="textcolor129">Or.intro_left q hp: p <span 
class="lmsy-10">&#x2228; </span>q</span></span> is also a proof (also written as <span class="texthl"><span id="textcolor130">Or.inl hp</span></span>)
     <!--l. 64--><p class="noindent" >Let <span class="texthl"><span id="textcolor131">hq: q</span></span> be a proof, then <span class="texthl"><span id="textcolor132">Or.intro_right p hq: p <span 
class="lmsy-10">&#x2228; </span>q</span></span> is also a proof (also written as <span class="texthl"><span id="textcolor133">Or.inr hq</span></span>)
     </li>
     <li class="itemize">
     <!--l. 66--><p class="noindent" ><span class="texthl"><span id="textcolor134">Or</span></span> admits one or-elimination rule: <span class="texthl"><span id="textcolor135">Or.elim</span></span>
     <!--l. 68--><p class="noindent" >Let <span class="texthl"><span id="textcolor136">hpq: p <span 
class="lmsy-10">&#x2228; </span>q</span></span>, <span class="texthl"><span id="textcolor137">hpr: p <span 
class="lmsy-10">&#x2192; </span>r</span></span>, and <span class="texthl"><span id="textcolor138">hqr: q <span 
class="lmsy-10">&#x2192; </span>r</span></span> be proofs, then <span class="texthl"><span id="textcolor139">Or.elim hpq hpr hqr: r</span></span> is also a proof</li></ul>
<!--l. 72--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.6   </span> <a 
 id="x1-110002.6"></a>NEGATION <span 
class="lmsy-10">¬</span></h3>
<!--l. 74--><p class="noindent" >Given a proposition <span class="texthl"><span id="textcolor140">p: Prop</span></span>, <span class="texthl"><span id="textcolor141"><span 
class="lmsy-10">¬ </span>p</span></span> is a propositon (also written as <span class="texthl"><span id="textcolor142">Not p</span></span>). <span class="texthl"><span id="textcolor143"><span 
class="lmsy-10">¬ </span>p</span></span> is precisely <span class="texthl"><span id="textcolor144">p <span 
class="lmsy-10">&#x2192; </span>False</span></span>
                                                                                               
                                                                                               
<!--l. 76--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.7   </span> <a 
 id="x1-120002.7"></a>LOGICAL EQUIVALENCE <span 
class="lmsy-10">&#x2194;</span></h3>
<!--l. 78--><p class="noindent" >Given two propositions <span class="texthl"><span id="textcolor145">p: Prop</span></span> and <span class="texthl"><span id="textcolor146">q: Prop</span></span>, <span class="texthl"><span id="textcolor147">p <span 
class="lmsy-10">&#x2194; </span>q: Prop</span></span> is a proposition (also written as <span class="texthl"><span id="textcolor148">Iff p q</span></span>)
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 81--><p class="noindent" ><span class="texthl"><span id="textcolor149">Iff</span></span> admits an iff-introduction rule: <span class="texthl"><span id="textcolor150">Iff.intro</span></span>
     <!--l. 83--><p class="noindent" >Let <span class="texthl"><span id="textcolor151">hpq: p <span 
class="lmsy-10">&#x2192; </span>q</span></span> and <span class="texthl"><span id="textcolor152">hqp: q <span 
class="lmsy-10">&#x2192; </span>p</span></span> be proofs, then <span class="texthl"><span id="textcolor153">Iff.intro hpq hqp: p <span 
class="lmsy-10">&#x2194; </span>q</span></span> is also a proof
     </li>
     <li class="itemize">
     <!--l. 85--><p class="noindent" ><span class="texthl"><span id="textcolor154">Iff</span></span> admits two iff-elimination rules: <span class="texthl"><span id="textcolor155">Iff.mp</span></span>, <span class="texthl"><span id="textcolor156">Iff.mpr</span></span>
     <!--l. 88--><p class="noindent" >Let <span class="texthl"><span id="textcolor157">h: p <span 
class="lmsy-10">&#x2194; </span>q</span></span> be a proof, then <span class="texthl"><span id="textcolor158">Iff.mp h: p <span 
class="lmsy-10">&#x2192; </span>q</span></span> and <span class="texthl"><span id="textcolor159">Iff.mpr h: q <span 
class="lmsy-10">&#x2192; </span>p</span></span> are also proofs</li></ul>
<!--l. 91--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.8   </span> <a 
 id="x1-130002.8"></a>UNIVERSAL QUANTIFIER <span 
class="lmsy-10">&#x2200;</span></h3>
<!--l. 93--><p class="noindent" >Let <span class="texthl"><span id="textcolor160"><span 
class="lmmi-10">&#x03B1;</span></span></span> be any object and <span class="texthl"><span id="textcolor161">p: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192; </span>Prop</span></span> be a map, then <span class="texthl"><span id="textcolor162"><span 
class="lmsy-10">&#x2200; </span>x: <span 
class="lmmi-10">&#x03B1;</span>, p x</span></span> is a proposition. An element of <span class="texthl"><span id="textcolor163"><span 
class="lmsy-10">&#x2200; </span>x: <span 
class="lmmi-10">&#x03B1;</span>, p x</span></span> is of the form <span class="texthl"><span id="textcolor164">hpx {x
: <span 
class="lmmi-10">&#x03B1;</span>} : <span 
class="lmmi-10">&#x03B1; </span><span 
class="ts1-lmss10-">&#x2192; </span>p x</span></span>, that is a function mapping <span class="texthl"><span id="textcolor165">x: <span 
class="lmmi-10">&#x03B1;</span></span></span> into a proof for <span class="texthl"><span id="textcolor166">p x</span></span>. The introduction rules and elimination rules are then obvious
from the context.
<!--l. 95--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.9   </span> <a 
 id="x1-140002.9"></a>EXISTENTIAL QUANTIFIER <span 
class="lmsy-10">&#x2203;</span></h3>
<!--l. 97--><p class="noindent" >Let <span class="texthl"><span id="textcolor167"><span 
class="lmmi-10">&#x03B1;</span></span></span> be any object and <span class="texthl"><span id="textcolor168">p: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192; </span>Prop</span></span> be a map, then <span class="texthl"><span id="textcolor169"><span 
class="lmsy-10">&#x2203; </span>x: <span 
class="lmmi-10">&#x03B1;</span>, p x</span></span> is a proposition.
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 100--><p class="noindent" ><span class="texthl"><span id="textcolor170">Exists</span></span> admits one introduction rule: <span class="texthl"><span id="textcolor171">Exists.intro</span></span>
     <!--l. 102--><p class="noindent" >Let <span class="texthl"><span id="textcolor172">x : <span 
class="lmmi-10">&#x03B1;</span></span></span> be an element and <span class="texthl"><span id="textcolor173">hpx: p x</span></span> be a proof, then <span class="texthl"><span id="textcolor174">Exists.intro x hpx: (<span 
class="lmsy-10">&#x2203; </span>x: <span 
class="lmmi-10">&#x03B1;</span>, p x)</span></span> is also a proof
     </li>
     <li class="itemize">
     <!--l. 104--><p class="noindent" ><span class="texthl"><span id="textcolor175">Exists</span></span> admits one elimination rule: <span class="texthl"><span id="textcolor176">Exists.elim</span></span>
     <!--l. 106--><p class="noindent" >Let <span class="texthl"><span id="textcolor177">hp: (<span 
class="lmsy-10">&#x2203; </span>x: <span 
class="lmmi-10">&#x03B1;</span>, p x)</span></span> and <span class="texthl"><span id="textcolor178">hpq: (<span 
class="lmsy-10">&#x2200; </span>y: <span 
class="lmmi-10">&#x03B1;</span>, p y <span 
class="lmsy-10">&#x2192; </span>q)</span></span> be proofs, then <span class="texthl"><span id="textcolor179">Exists.elim hp hpq: q</span></span> is a proof</li></ul>
<!--l. 109--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.10   </span> <a 
 id="x1-150002.10"></a>CLASSICAL LOGIC</h3>
                                                                                               
                                                                                               
<!--l. 111--><p class="noindent" >So far, we introduced constructive logic, that is, if a proposition is true, then we are able to construct a certificate. However, it
will be useful if we accept non-constructive proof, that is, assuming law of excluded middle: for any proposition <span class="texthl"><span id="textcolor180">p:
Prop</span></span>, <span class="texthl"><span id="textcolor181">p <span 
class="lmsy-10">&#x2228;¬ </span>p</span></span> is true. In lean, we can obtain a proof for <span class="texthl"><span id="textcolor182">p <span 
class="lmsy-10">&#x2228;¬ </span>p</span></span> from <span class="texthl"><span id="textcolor183">Classical.em p</span></span>. Law of excluded middle also
induces the principal of double-negation elimination: for any proposition <span class="texthl"><span id="textcolor184">p: Prop</span></span>, <span class="texthl"><span id="textcolor185"><span 
class="lmsy-10">¬¬ </span>p <span 
class="lmsy-10">&#x2194; </span>p</span></span>. With the principal of
double-negation elimination, one is able to carry out proof by contradiction, which is generally not possible in constructive
logic.
<!--l. 113--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">2.11   </span> <a 
 id="x1-160002.11"></a>AUXILIARY SUBGOALS</h3>
<!--l. 115--><p class="noindent" >See examples in <a 
href="../theorem_proving_in_lean_4/theorem_proving/auxiliary_subgoals.lean" >auxiliary_subgoals.lean</a>
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;3</span><br /><a 
 id="x1-170003"></a>EQUALITY: CALCULATION PROOF</h2>
<h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-180003.1"></a>EQUALITY</h3>
<!--l. 7--><p class="noindent" >Let <span class="texthl"><span id="textcolor186">a</span></span> and <span class="texthl"><span id="textcolor187">b</span></span> be any objects, then <span class="texthl"><span id="textcolor188">a = b</span></span> is a proposition (also written as <span class="texthl"><span id="textcolor189">Eq a b</span></span>). <span class="texthl"><span id="textcolor190">Eq</span></span> admits several properties
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 10--><p class="noindent" >(reflexive): <span class="texthl"><span id="textcolor191">Eq.refl</span></span>
     <!--l. 12--><p class="noindent" >Let <span class="texthl"><span id="textcolor192">a</span></span> be any object, then <span class="texthl"><span id="textcolor193">Eq.refl a: a = a</span></span> is a proof
     </li>
     <li class="itemize">
     <!--l. 14--><p class="noindent" >(symmetric): <span class="texthl"><span id="textcolor194">Eq.symm</span></span>
     <!--l. 16--><p class="noindent" >Let <span class="texthl"><span id="textcolor195">hab: a = b</span></span> be a proof, then <span class="texthl"><span id="textcolor196">Eq.symm hab: b = a</span></span> is also a proof
     </li>
     <li class="itemize">
     <!--l. 18--><p class="noindent" >(transitive): <span class="texthl"><span id="textcolor197">Eq.trans</span></span>
     <!--l. 20--><p class="noindent" >Let <span class="texthl"><span id="textcolor198">hab: a = b</span></span>, <span class="texthl"><span id="textcolor199">hbc: b = c</span></span> be proofs, then <span class="texthl"><span id="textcolor200">Eq.trans hab hbc: a = c</span></span> is also a proof</li></ul>
<!--l. 23--><p class="noindent" >In proving equality, lean provides several substitution rules
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 26--><p class="noindent" ><span class="texthl"><span id="textcolor201">Eq.subst</span></span>
     <!--l. 28--><p class="noindent" >Let <span class="texthl"><span id="textcolor202">x: <span 
class="lmmi-10">&#x03B1;</span></span></span> and <span class="texthl"><span id="textcolor203">y: <span 
class="lmmi-10">&#x03B1;</span></span></span>. Let <span class="texthl"><span id="textcolor204">h: a = b</span></span> be a proof and <span class="texthl"><span id="textcolor205">p: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192; </span>Prop</span></span>, then if <span class="texthl"><span id="textcolor206">hx: p x</span></span> is a proof, then <span class="texthl"><span id="textcolor207">Eq:subst: p y</span></span> is also
     a proof
     </li>
     <li class="itemize">
     <!--l. 30--><p class="noindent" ><span class="texthl"><span id="textcolor208">congrArg</span></span>
     <!--l. 32--><p class="noindent" >Let <span class="texthl"><span id="textcolor209">x: <span 
class="lmmi-10">&#x03B1;</span></span></span> and <span class="texthl"><span id="textcolor210">y: <span 
class="lmmi-10">&#x03B1;</span></span></span>. Let <span class="texthl"><span id="textcolor211">h: a = b</span></span> be a proof and <span class="texthl"><span id="textcolor212">f: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span>, then <span class="texthl"><span id="textcolor213">congrArg f h: f x = f y</span></span> is a proof
     </li>
     <li class="itemize">
     <!--l. 34--><p class="noindent" ><span class="texthl"><span id="textcolor214">congrFun</span></span>
     <!--l. 36--><p class="noindent" >Let <span class="texthl"><span id="textcolor215">f: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> and <span class="texthl"><span id="textcolor216">g: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span>. Let <span class="texthl"><span id="textcolor217">h: f = g</span></span> and <span class="texthl"><span id="textcolor218">x: <span 
class="lmmi-10">&#x03B1;</span></span></span>, then <span class="texthl"><span id="textcolor219">congrFun h x: f x = g x</span></span> is a proof
     </li>
     <li class="itemize">
     <!--l. 38--><p class="noindent" ><span class="texthl"><span id="textcolor220">congr</span></span>
     <!--l. 40--><p class="noindent" >Let <span class="texthl"><span id="textcolor221">x: <span 
class="lmmi-10">&#x03B1;</span></span></span> and <span class="texthl"><span id="textcolor222">y: <span 
class="lmmi-10">&#x03B1;</span></span></span>. Let <span class="texthl"><span id="textcolor223">f: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span> and <span class="texthl"><span id="textcolor224">g: <span 
class="lmmi-10">&#x03B1; </span><span 
class="lmsy-10">&#x2192;</span><span 
class="lmmi-10">&#x03B2;</span></span></span>. Let <span class="texthl"><span id="textcolor225">h_1: x = y</span></span> and <span class="texthl"><span id="textcolor226">h_2: f = g</span></span>, then <span class="texthl"><span id="textcolor227">congr h_2 h_1: f x = g y</span></span> is
     a proof</li></ul>
                                                                                               
                                                                                               
<!--l. 43--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-190003.2"></a>CALCULATION PROOF - REWRITE TACTIC</h3>
<!--l. 45--><p class="noindent" >See examples for <span class="texthl"><span id="textcolor228">calc</span></span> and <span class="texthl"><span id="textcolor229">rewrite</span></span>, <span class="texthl"><span id="textcolor230">simp</span></span> tactics in <a 
href="theorem_proving_in_lean_4/theorem_proving/calculation_proof.lean" >calculation_proof.lean</a>
<!--l. 47--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-200003.3"></a>TRANSITIVITY AND CALCULATION PROOF</h3>
<!--l. 49--><p class="noindent" >Calculation proof also works for inequalities or more generally any transitive binary relation
<!--l. 51--><p class="noindent" >See examples in <a 
href="../theorem_proving_in_lean_4/theorem_proving/calculation_proof_for_transitivity.lean" >calculation_proof_for_transitivity.lean</a>
<!--l. 53--><p class="noindent" ><span id="textcolor231"><span 
class="ec-lmsso-10">NOTE: we might not understand everything at the moment - bare with me, accept it exists and move on first</span></span>
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;4</span><br /><a 
 id="x1-210004"></a>TACTIC: <br 
class="newline" />LEAN AS A THEOREM PROVER</h2>
<!--l. 3--><p class="noindent" >Keywords: <span 
class="ec-lmsso-10">tactic</span>
<!--l. 5--><p class="noindent" >Enter tactic mode: <span 
class="ec-lmsso-10">tactics </span>make Lean be a theorem prover instead of a theorem verifier. Tactics enable proving
theorem in Lean by providing a list of instructions how to prove a theorem and Lean will automatically fill in the
details.
<!--l. 7--><p class="noindent" >A proof in tactic mode starts with <span class="texthl"><span id="textcolor232">by</span></span> and follows by a sequence of instructions. In tactic mode, user gives instruction to fulfill a
goal.
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;5</span><br /><a 
 id="x1-220005"></a>PROOF BY INDUCTION: <br 
class="newline" />THE NATURAL NUMBERS</h2>
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
                                                                                               
<h2 class="likechapterHead"><a 
 id="x1-23000"></a>Bibliography</h2>
   <div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
<a 
 id="XDavidThraneChristiansen"></a>[1] <span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>David&#x00A0;Thrane
   Christiansen.  Functional programming in lean.  <a 
href="https://lean-lang.org/functional_programming_in_lean/" class="url" >https://lean-lang.org/functional_programming_in_lean/</a>, 2025.
   Accessed: May 7, 2025.
   </p>
   <p class="bibitem" ><span class="biblabel">
<a 
 id="XCH"></a>[2] <span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>Curry-Howard.
   Curry-howard correspondence.  <a 
href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" class="url" >https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence</a>, 2025.
   Accessed: May 7, 2025.
   </p>
   <p class="bibitem" ><span class="biblabel">
<a 
 id="XJeremy"></a>[3] <span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>Soonho&#x00A0;Kong  Jeremy&#x00A0;Avigad,  Leonardo  de&#x00A0;Moura  and  with  contributions  from  the  Lean&#x00A0;Community
   Sebastian&#x00A0;Ullrich. Theorem proving in lean 4. <a 
href="https://lean-lang.org/theorem_proving_in_lean4/" class="url" >https://lean-lang.org/theorem_proving_in_lean4/</a>, 2025. Accessed:
   May 7, 2025.
   </p>
   <p class="bibitem" ><span class="biblabel">
<a 
 id="XLuisWirth"></a>[4] <span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>Luis Wirth.  Lean4 and the curry-howard isomorphism (luis wirth).  <a 
href="https://youtu.be/Sy_4z751YWI" class="url" >https://youtu.be/Sy_4z751YWI</a>, 2025.
   Accessed: May 7, 2025.
</p>
   </div>
 
</body></html> 

                                                                                               



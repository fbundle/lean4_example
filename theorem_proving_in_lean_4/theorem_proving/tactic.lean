-- `Control-Shift-Enter` or `Command-Shift-Enter` to show `Lean InfoView`

theorem t {p q: Prop} : p ∧ q → p ∨ q := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∨ q`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∨ q`
  apply Or.intro_left
  -- current goal: `case h ; p q : Prop ; h : p ∧ q ⊢ p`
  exact h.left
  -- current goal: no more goal - proof is complete

#print t -- print the proof generated by lean

example {p q: Prop} : p ∧ q → p ∧ q ∧ p := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∧ q ∧ p`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∧ q ∧ p`
  apply And.intro
  -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ p`
  -- current goal 2: `case right ; p q : Prop ; h : p ∧ q ⊢ q ∧ p`
  case left => -- do `case left` first
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ p`
    exact h.left
  case right =>
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ q ∧ p`
    apply And.intro
    -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ q`
    -- current goal 2: `case right ; p q : Prop ; h: p ∧ q ⊢ p`
    case right => -- do `case right` first
      -- current goal: `p q : Prop ; h: p ∧ q ⊢ p`
      exact h.left
    case left =>
      -- current goal: `p q : Prop ; h : p ∧ q ⊢ q`
      exact h.right

-- example for `intro` that can be used to intro several variables
example : ∀ a b c : Nat, a = b ∧ a = c → c = b := by
  intro a b c h -- `a b c : Nat ; h : a = b ∧ a = c`
  have h₁ := h.left
  have h₂ := h.right
  exact Eq.trans (Eq.symm h₂) h₁

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂ -- `a b c : Nat ; h₁ : a = b ; h₂ : a = c`
  exact Eq.trans (Eq.symm h₂) h₁

-- example for `intro` using `⟨ ... ⟩` constructor
example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩ -- `w` is a term that witnesses `p w ∧ q w`
  exact ⟨w, hqw, hpw⟩

-- example for `assumption`
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  -- current goal: `x y z w : Nat ;  h₁ : x = y ; h₂ : y = z ; h₃ : z = w`
  -- `assumption` automatically find the assumption to fulfill the goal
  assumption -- here it uses `h₃`

-- example for `intros` and `assumption`
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption

-- example for `intros`, `assumption`, and `repeat
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  repeat assumption -- repeat assumption until goal is fulfilled

-- example for `revert` and `rfl`
example (x : Nat) : x = x := by
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  exact rfl -- `rfl` proves all `x ∼ x` for every reflexive relation `∼`


-- example for `generalize`
example : 3 = 3 := by
  generalize 3 = x
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  rfl

-- decompose a disjunction with `cases`
example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h
  -- current goal : `p q : Prop ;h : p ∨ q ⊢ q ∨ p`
  cases h with
  | inl hp =>
    -- current goal : `p q : Prop ; hp : p ⊢ q ∨ p`
    apply Or.inr; exact hp
  | inr hq =>
    -- current goal : `p q : Prop ; hq : q ⊢ q ∨ p`
    apply Or.inl; exact hq

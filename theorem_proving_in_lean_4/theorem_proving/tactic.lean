-- `Control-Shift-Enter` or `Command-Shift-Enter` to show `Lean InfoView`


-- easy example with `intro`
theorem t {p q: Prop} : p ∧ q → p ∨ q := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∨ q`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∨ q`
  apply Or.intro_left
  -- current goal: `case h ; p q : Prop ; h : p ∧ q ⊢ p`
  exact h.left
  -- current goal: no more goal - proof is complete

#print t -- print the proof generated by lean

-- a more complicated example
example {p q: Prop} : p ∧ q → p ∧ q ∧ p := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∧ q ∧ p`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∧ q ∧ p`
  apply And.intro
  -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ p`
  -- current goal 2: `case right ; p q : Prop ; h : p ∧ q ⊢ q ∧ p`
  case left => -- do `case left` first
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ p`
    exact h.left
  case right =>
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ q ∧ p`
    apply And.intro
    -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ q`
    -- current goal 2: `case right ; p q : Prop ; h: p ∧ q ⊢ p`
    case right => -- do `case right` first
      -- current goal: `p q : Prop ; h: p ∧ q ⊢ p`
      exact h.left
    case left =>
      -- current goal: `p q : Prop ; h : p ∧ q ⊢ q`
      exact h.right

-- introduce variables
example : ∀ a b c : Nat, a = b ∧ a = c → c = b := by
  intro a b c h -- `a b c : Nat ; h : a = b ∧ a = c`
  have h₁ := h.left
  have h₂ := h.right
  exact Eq.trans (Eq.symm h₂) h₁

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂ -- `a b c : Nat ; h₁ : a = b ; h₂ : a = c`
  exact Eq.trans (Eq.symm h₂) h₁

-- example for `intro` using `⟨ ... ⟩` constructor
example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩ -- `w` is a term that witnesses `p w ∧ q w`
  exact ⟨w, hqw, hpw⟩

-- example for `assumption`
example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁
  apply Eq.trans h₂
  -- current goal: `x y z w : Nat ;  h₁ : x = y ; h₂ : y = z ; h₃ : z = w`
  -- `assumption` automatically find the assumption to fulfill the goal
  assumption -- here it uses `h₃`

-- example for `intros` and `assumption`
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption

-- example for `intros`, `assumption`, and `repeat`
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros -- intro all variables but the names are hidden by default
  apply Eq.trans
  apply Eq.symm
  repeat assumption -- repeat assumption until goal is fulfilled

-- example for `revert` and `rfl`
example (x : Nat) : x = x := by
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  exact rfl -- `rfl` proves all `x ∼ x` for every reflexive relation `∼`


-- example for `generalize`
example : 3 = 3 := by
  generalize 3 = x
  -- current goal: `x : Nat ⊢ x = x`
  revert x
  -- current goal: `⊢ ∀ (x : Nat), x = x`
  intro y
  -- current goal: `y : Nat ⊢ y = y`
  rfl


-- decompose a disjunction with `cases`
example (p q : Prop) : p ∨ q → q ∨ p := by
  intro h -- `h : p ∨ q`
  -- current goal : `p q : Prop ; h : p ∨ q ⊢ q ∨ p`
  cases h with
  | inl hp =>
    -- current goal : `p q : Prop ; hp : p ⊢ q ∨ p`
    apply Or.inr; exact hp
  | inr hq =>
    -- current goal : `p q : Prop ; hq : q ⊢ q ∨ p`
    apply Or.inl; exact hq

-- decompose an existence by `cases`
-- prove for existence by `exists`
example (p q : Nat → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x := by
  intro h
  -- current goal: `p q : Nat → Prop ; h : ∃ x, p x ⊢ ∃ x, p x ∨ q x`
  cases h with
  | intro w pw =>
    -- current goal: `p q : Nat → Prop ; w : Nat ; pw : p ; w ⊢ ∃ x, p x ∨ q x`
    exists w -- tell `lean` that `w` is the chosen point to satisfy existential goal
    -- current goal: `p q : Nat → Prop ; w : Nat ; pw : p w ⊢ p w ∨ q w`
    apply Or.inl
    exact pw


-- proof by contradiction
example (p q : Prop) : p ∧ ¬p → q := by
  intro h
  have h₁ := h.left
  have h₂ := h.right
  contradiction -- search for contradiction

-- proof by contradiction
example (p q : Prop) : p ∧ ¬p → q := by
  intro h
  cases h -- created `left: p` and `right: p` automatically
  contradiction

-- mixed term-mode and tactic-mode
example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) :=
  by -- start tactic mode by `by`
  intro h
  exact -- start term mode by `exact`
    have hp : p := h.left
    have hqr : q ∨ r := h.right
    show (p ∧ q) ∨ (p ∧ r) by -- start tactic mode by `by`, `show (p ∧ q) ∨ (p ∧ r)` is optional
      cases hqr with
      | inl hq => exact Or.inl ⟨hp, hq⟩
      | inr hr => exact Or.inr ⟨hp, hr⟩

-- optional `show`
example {p q: Prop} : p ∧ q → q ∧ p := by
  intro h
  apply And.intro
  case left =>
    show q -- use show to specify which goal we are resolving
    exact h.right
  case right =>
    show p -- use show to specify which goal we are resolving
    exact h.left


-- alternative to proving multiple goals
/-
  apply foo
  . <proof of first goal>
  . <proof of second goal>
  . <proof of third goal>
  . <proof of final goal>

  apply foo
  case <tag of first goal>  => <proof of first goal>
  case <tag of second goal> => <proof of second goal>
  case <tag of third goal>  => <proof of third goal>
  case <tag of final goal>  => <proof of final goal>

  apply foo
  { <proof of first goal>  }
  { <proof of second goal> }
  { <proof of third goal>  }
  { <proof of final goal>  }
-/


example (f : Nat → Nat) (k : Nat) (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 := by
calc
  f k = f 0 := by rw [h₂]
  _   = 0 := by rw [h₁]

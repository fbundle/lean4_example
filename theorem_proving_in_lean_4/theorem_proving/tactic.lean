theorem t {p q: Prop} : p ∧ q → p ∨ q := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∨ q`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∨ q`
  apply Or.intro_left
  -- current goal: `case h ; p q : Prop ; h : p ∧ q ⊢ p`
  exact h.left
  -- current goal: no more goal - proof is complete

#print t -- print the proof generated by lean

example {p q: Prop} : p ∧ q → p ∧ q ∧ p := by
  -- current goal: `p q : Prop ⊢ p ∧ q → p ∧ q ∧ p`
  intro h
  -- current goal: `p q : Prop ; h: p ∧ q ⊢ p ∧ q ∧ p`
  apply And.intro
  -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ p`
  -- current goal 2: `case right ; p q : Prop ; h : p ∧ q ⊢ q ∧ p`
  case left => -- do `case left` first
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ p`
    exact h.left
  case right =>
    -- current goal: `p q : Prop ; h : p ∧ q ⊢ q ∧ p`
    apply And.intro
    -- current goal 1: `case left ; p q : Prop ; h : p ∧ q ⊢ q`
    -- current goal 2: `case right ; p q : Prop ; h: p ∧ q ⊢ p`
    case left =>
      -- current goal: `p q : Prop ; h : p ∧ q ⊢ q`
      exact h.right
    case right =>
      -- current goal: `p q : Prop ; h: p ∧ q ⊢ p`
      exact h.left

-- another example for `intro`
example : ∀ a b c : Nat, a = b ∧ a = c → c = b := by
  intro a b c h
  have h₁ := h.left
  have h₂ := h.right
  exact Eq.trans (Eq.symm h₂) h₁
